/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
'use strict';
var is = require('./utils/is');
var protocolCompletionItem_1 = require('./protocolCompletionItem');
function asOpenTextDocumentParams(textDocument) {
    return {
        uri: textDocument.uri.toString(),
        text: textDocument.getText()
    };
}
exports.asOpenTextDocumentParams = asOpenTextDocumentParams;
function isTextDocumentChangeEvent(value) {
    var candidate = value;
    return is.defined(candidate.document) && is.defined(candidate.contentChanges);
}
function isTextDocument(value) {
    var candidate = value;
    return is.defined(candidate.uri) && is.defined(candidate.version);
}
function asChangeTextDocumentParams(arg) {
    if (isTextDocument(arg)) {
        var result = {
            uri: arg.uri.toString(),
            contentChanges: [{ text: arg.getText() }]
        };
        return result;
    }
    else if (isTextDocumentChangeEvent(arg)) {
        var result = {
            uri: arg.document.uri.toString(),
            contentChanges: arg.contentChanges.map(function (change) {
                var range = change.range;
                return {
                    range: {
                        start: { line: range.start.line, character: range.start.character },
                        end: { line: range.end.line, character: range.end.character }
                    },
                    rangeLength: change.rangeLength,
                    text: change.text
                };
            })
        };
        return result;
    }
    else {
        throw Error('Unsupported text document change parameter');
    }
}
exports.asChangeTextDocumentParams = asChangeTextDocumentParams;
function asCloseTextDocumentParams(textDocument) {
    return {
        uri: textDocument.uri.toString()
    };
}
exports.asCloseTextDocumentParams = asCloseTextDocumentParams;
function asTextDocumentIdentifier(textDocument) {
    return { uri: textDocument.uri.toString() };
}
exports.asTextDocumentIdentifier = asTextDocumentIdentifier;
function asTextDocumentPosition(textDocument, position) {
    return { uri: textDocument.uri.toString(), position: asWorkerPosition(position) };
}
exports.asTextDocumentPosition = asTextDocumentPosition;
function asWorkerPosition(position) {
    return { line: position.line, character: position.character };
}
exports.asWorkerPosition = asWorkerPosition;
function asRange(value) {
    if (is.undefined(value)) {
        return undefined;
    }
    else if (is.nil(value)) {
        return null;
    }
    return { start: asPosition(value.start), end: asPosition(value.end) };
}
exports.asRange = asRange;
function asPosition(value) {
    if (is.undefined(value)) {
        return undefined;
    }
    else if (is.nil(value)) {
        return null;
    }
    return { line: value.line, character: value.character };
}
exports.asPosition = asPosition;
function set(value, func) {
    if (is.defined(value)) {
        func();
    }
}
function asCompletionItem(item) {
    var result = { label: item.label };
    set(item.detail, function () { return result.detail = item.detail; });
    set(item.documentation, function () { return result.documentation = item.documentation; });
    set(item.filterText, function () { return result.filterText = item.filterText; });
    set(item.insertText, function () { return result.insertText = item.insertText; });
    // Protocol item kind is 1 based, codes item kind is zero based.
    set(item.kind, function () { return result.kind = item.kind + 1; });
    set(item.sortText, function () { return result.sortText = item.sortText; });
    set(item.textEdit, function () { return result.textEdit = asTextEdit(item.textEdit); });
    if (item instanceof protocolCompletionItem_1.default) {
        set(item.data, function () { return result.data = item.data; });
    }
    return result;
}
exports.asCompletionItem = asCompletionItem;
function asTextEdit(edit) {
    return { range: asRange(edit.range), newText: edit.newText };
}
exports.asTextEdit = asTextEdit;
function asReferenceParams(textDocument, position, options) {
    return {
        uri: textDocument.uri.toString(),
        position: asWorkerPosition(position),
        context: { includeDeclaration: options.includeDeclaration }
    };
}
exports.asReferenceParams = asReferenceParams;
