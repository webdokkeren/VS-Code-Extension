"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var _postcss = require("postcss");

var _postcss2 = _interopRequireDefault(_postcss);

var _globby = require("globby");

var _globby2 = _interopRequireDefault(_globby);

var _fs = require("fs");

var _fs2 = _interopRequireDefault(_fs);

var _queueAsync = require("queue-async");

var _queueAsync2 = _interopRequireDefault(_queueAsync);

var _postcssScss = require("postcss-scss");

var _postcssScss2 = _interopRequireDefault(_postcssScss);

var _postcssPlugin = require("./postcssPlugin");

var _postcssPlugin2 = _interopRequireDefault(_postcssPlugin);

var _formatters = require("./formatters");

var _formatters2 = _interopRequireDefault(_formatters);

exports["default"] = function () {
  var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

  var files = _ref.files;
  var code = _ref.code;
  var config = _ref.config;
  var configBasedir = _ref.configBasedir;
  var configOverrides = _ref.configOverrides;
  var syntax = _ref.syntax;
  var _ref$formatter = _ref.formatter;
  var formatter = _ref$formatter === undefined ? "json" : _ref$formatter;

  if (!files && !code || files && code) {
    throw new Error("You must pass stylelint a `files` glob or a `code` string, though not both");
  }

  return new Promise(function (resolve, reject) {
    var chosenFormatter = typeof formatter === "string" ? _formatters2["default"][formatter] : formatter;

    var postcssResults = [];
    var results = [];
    var errored = false;

    var inputReady = files ? (0, _globby2["default"])(files) : Promise.resolve(code);
    inputReady.then(function (input) {
      var q = (0, _queueAsync2["default"])();

      if (typeof input === "string") {
        q.defer(lint, input, null);
      } else {
        if (!input.length) {
          var err = new Error("Files glob patterns specified did not match any files");
          err.code = 80;
          reject(err);
        }
        input.forEach(function (filepath) {
          q.defer(lintFile, filepath);
        });
      }

      q.awaitAll(function (err) {
        if (err) {
          reject(err);
        }
        var output = chosenFormatter(results);
        resolve({ output: output, results: results, postcssResults: postcssResults, errored: errored });
      });
    });

    function lintFile(filepath, cb) {
      _fs2["default"].readFile(filepath, "utf8", function (err, code) {
        if (err) {
          reject(err);
        }
        lint(code, filepath, cb);
      });
    }

    function lint(code, filepath, cb) {
      var processOptions = {};
      if (filepath) {
        processOptions.from = filepath;
      }
      if (syntax === "scss") {
        processOptions.syntax = _postcssScss2["default"];
      }
      (0, _postcss2["default"])().use((0, _postcssPlugin2["default"])({ config: config, configBasedir: configBasedir, configOverrides: configOverrides })).process(code, processOptions).then(function (postcssResult) {
        var source = !postcssResult.root.source ? undefined : postcssResult.root.source.input.file || postcssResult.root.source.input.id;

        if (postcssResult.stylelint.stylelintError) {
          errored = true;
        }
        results.push({
          source: source,
          errored: postcssResult.stylelint.stylelintError,
          warnings: postcssResult.messages.map(function (message) {
            return {
              line: message.line,
              column: message.column,
              rule: message.rule,
              severity: message.severity,
              text: message.text
            };
          })
        });
        cb();
      })["catch"](cb);
    }
  });
};

module.exports = exports["default"];