#!/usr/bin/env node
"use strict";

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var _meow = require("meow");

var _meow2 = _interopRequireDefault(_meow);

var _path = require("path");

var _path2 = _interopRequireDefault(_path);

var _lodash = require("lodash");

var _getStdin = require("get-stdin");

var _getStdin2 = _interopRequireDefault(_getStdin);

var _standalone = require("./standalone");

var _standalone2 = _interopRequireDefault(_standalone);

var minimistOptions = {
  "default": {
    f: "string",
    q: false
  },
  alias: {
    f: "formatter",
    q: "quiet",
    s: "syntax"
  }
};
var syntaxOptions = ["scss"];

var meowOptions = {
  help: ["Usage", "  stylelint [input] [options]", "", "By default, stylelint will look for a .stylelintrc file in JSON format,", "using rc to look in various places (cf. https://github.com/dominictarr/rc#standards).", "Alternately, you can specify a configuration file via --config.", "", "Input", "  File glob(s) (passed to node-glob).", "  You can also pass no input and use stdin.", "", "Options", "  --config            Path to a JSON configuration file.", "  --version           Get the currently installed version of stylelint.", "  --custom-formatter  Path to a JS file exporting a custom formatting function", "  -f, --formatter     Specify a formatter: \"json\" or \"string\". Default is \"string\".", "  -q, --quiet         Only register warnings for rules with a severity of 2 (ignore level 1)", "  -s, --syntax        Specify a non-standard syntax that should be used to ", "                      parse source stylesheets. Options: \"scss\""],
  pkg: "../package.json"
};

var cli = (0, _meow2["default"])(meowOptions, minimistOptions);

var formatter = cli.flags.customFormatter ? require(_path2["default"].join(process.cwd(), cli.flags.customFormatter)) : cli.flags.formatter;

var optionsBase = {
  formatter: formatter,
  configOverrides: {}
};

if (cli.flags.quiet) {
  optionsBase.configOverrides.quiet = cli.flags.quiet;
}

if (cli.flags.s && (0, _lodash.includes)(syntaxOptions, cli.flags.s)) {
  optionsBase.syntax = cli.flags.s;
}

var optionsReady = cli.input.length ? Promise.resolve((0, _lodash.assign)({}, optionsBase, {
  files: cli.input
})) : (0, _getStdin2["default"])().then(function (stdin) {
  return Promise.resolve((0, _lodash.assign)({}, optionsBase, {
    code: stdin
  }));
});

optionsReady.then(function (options) {
  (0, _standalone2["default"])(options).then(function (_ref) {
    var output = _ref.output;
    var errored = _ref.errored;

    if (!output) {
      return;
    }
    process.stdout.write(output);
    if (errored) {
      process.exit(2);
    }
  })["catch"](function (err) {
    console.log(err.stack);
    process.exit(err.code || 1);
  });
});